Πρώτη εργασία Προγραμματισού συστήματος
Χαράλαμπος Κιοσές

	Στο φάκελο που σας παραδίδω υπάρχουν τα εξής αρχεία:
main.cpp,Hash.h,Bucket.h,Bucket.cpp,List.h,List.cpp
Heap.h,Heap.cpp,Cdr.h,Cdr.cpp,Makefile,README

	Το πρόγραμμα ξεκινάει διαβάζοντας τα απαραίτητα ορίσματα απο
την γραμμή εντολών. Στην συνέχεια δημιουργεί τις κατάλληλες δομές
και ξεκινά να διαβάζει απο το αρχείο operations αν υπάρχει, αλλιώς
περιμένει είσοδο στο stdin. Τερματίζει και απελευθερώνει μνήμη μόλις
δωθεί το bye.

	Δομές:
Hash<T>: Είναι η δομή του hashtable και περιέχει την τιμή με το μέγεθος του
(tsize)καθώς και εναν πίνακα μεγέθους tsize απο δείκτες σε λίστα<T> (table).
Ουσιαστικά μπορεί να είναι είτε λίστα απο Bucket_caller είτε Bucket_receiver.

Bucket_caller: Κουβάς για το hashable που έχουν κλειδί το originator number.
Περιέχει το μέγιστο μέγεθος του (bsize) καθώς και το τρέχον μέγεθος (counter).
Επίσης περιέχει εναν πίνακα μεγέθους bsize απο struct caller node (cells).
Το caller_node έχει το κλειδί του κάθε caller έναν δείκτη σε heap_node και
εναν δείκτη σε λίστα με Buckets.

Bucket_receiver: Παρόμοιω με το Bucket_caller, είναι για το hashtable που 
έχει κλειδί το callee number. Η διαφορά ειναι οτι στο αντίστοιχο receiver_node
δεν χρειάζεται να έχει δείκτη σε heap_node.

Bucket:Είναι η δομή που παρουσιάζεται στο σχήμα της άσκησης σαν δεύτερος κουβάς.
Περιέχει το μέγιστο μέγεθος του και το τρέχον όπως οι απο πάνω δομές καθώς και 
έναν πίνακα απο δείκτες σε κόμβους λίστα με Cdr.

Αυτή η λίστα με τα cdr είναι μια δομή στην οποία μπορούν να φτάσουμε και απο τα
2 hashtable μέσο δεικτών απο τα Bucket. Εκεί είναι αποθηκευμένα όλα τα Cdr και 
τίποτα δεν διαγράφεται μέχρι το τέλος του προγράμματος. Στο μεταξύ μπορεί να γίνουν
διαγραφές απο τα hashtable που σβήνουν μόνο τους δείκτες στους κόμβους της λίστας.
Αυτό γίνεται ώστε να μήν υπάρχουν duplicate Cdrs.

Η διαδικασία insert έχει υλοποιηεί με συνάρτηση αντίστοιχου ονόματος του hashtable.
Θα βρείτε 2 συναρτήσεις insert την 1 με 2 ορίσματα και την άλλη με 3. Αυτό γίνεται
ώστε οταν έχουμε εισαγωγή σε hashtable caller να ενημερώνεται ή να εισάγεται αντίστοιχως
κόμβος στην δομή heap.

Heap: Είναι η δομή σωρού, περιέχει μια ρίζα εναν μετρητή κόμβων και ένα μετρητή ύψους.
Αυτοί οι δυο μετρητές χρησιμοποιούνται ώστε να βρίσκουμε γρήγοτα την θέση στην οποία 
θα μπεί ο νεος κόμβος (κατώτερο ύψος και αριστερότερα). Με τις συναρτήσεις sort και 
swap που καλούνται είτε απο την insert είτε απο την update του heap αλλάζουν θέση 
οι κόμβοι του δέντρου ώστε να έχουμε πάντα μικρότερη τιμή value σε παιδί και μεγαλύτερη
σε πατέρα.

Στην delete υπάρχει κάποιο πρόβλημα σχετικά με την διαγραφή των υψηλότερων επιπέδων Bucket.

Έγινε προσπάθεια υλοποίησης της indist δεν εχει ολοκληρωθεί.
Επίσης δεν εχουν ολοκληρωθεί οι: top,topdest. Παρόλα αυτά όλες οι δομές είναι έτοιμες.
Έγινε έλεγχος μνήμης με valgrind όπου δεν διαπυστώθηκε κάποιο πρόβλημα(υπάρχει έτοιμη στο Makefile)
Έχει υλοποιηθεί η dump.
Makefile:make   ->link->compile δημιουργία εκτελέσιμου.
		make clean διαγραφή objects και εκτελέσιμου
		make run   -> ./exe
		make valgrind έλεγχος μνήμης
		 
Τα περισσότερα prints είναι σχολιασμένα για να μήν καθυστερεί η εκτέλεση.


!!!!!ΑΛΛΑΞΑ ΤΗΝ HEAP Απο char * to key se long long int
ΠΡΕΠΕΙ ΝΑ ΤΟ ΦΤΙΑΞΩ!!!!!!!!!
